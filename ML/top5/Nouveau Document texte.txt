üß† Objectif du script
Recommander √† chaque candidat une seule offre d‚Äôemploi qui correspond le mieux √† ses comp√©tences (Skills) √† l‚Äôaide d‚Äôun syst√®me de recommandation bas√© contenu (content-based filtering), avec TF-IDF + similarit√© cosinus.

üß± Structure du script
1. Connexion √† la base SQL Server
python
Copier
Modifier
connexion = pypyodbc.connect(...)
Connexion √† la base DW_ADMISSION

Requ√™tes SQL ex√©cut√©es avec pandas.read_sql() pour r√©cup√©rer :

Les candidats avec FullName et Skills

Les offres avec Title et Description

2. Pr√©traitement des donn√©es
python
Copier
Modifier
jobs.columns = [col.lower() for col in jobs.columns]
candidats.columns = [col.lower() for col in candidats.columns]
Toutes les colonnes sont converties en minuscules pour √©viter les erreurs de nom de colonne.

Fusion des colonnes title + description dans une nouvelle colonne job_text :

python
Copier
Modifier
jobs['job_text'] = jobs['title'].fillna('') + ' ' + jobs['description'].fillna('')
3. Cr√©ation d‚Äôun vecteur TF-IDF
python
Copier
Modifier
vectorizer = TfidfVectorizer(stop_words=french_stopwords)
job_vectors = vectorizer.fit_transform(jobs['job_text'])
TF-IDF transforme le texte des offres en vecteurs num√©riques

Les mots fr√©quents en fran√ßais sont ignor√©s (ex: "le", "et", "√†", etc.)

4. Calcul de similarit√© (pour chaque candidat)
python
Copier
Modifier
for _, candidat in candidats.iterrows():
    skill_vector = vectorizer.transform([candidat['skills']])
    similarities = cosine_similarity(skill_vector, job_vectors).flatten()
    best_idx = similarities.argmax()
Les comp√©tences du candidat (skills) sont vectoris√©es

On calcule la similarit√© cosinus entre son profil et chaque offre

On s√©lectionne l‚Äôoffre avec la plus grande similarit√© (argmax())

5. Construction du tableau final
python
Copier
Modifier
results.append({
    'Candidat': candidat['fullname'],
    'Skills': candidat['skills'],
    'Reco_JobID': jobs.iloc[best_idx]['pk_jobs'],
    'Reco_JobTitle': jobs.iloc[best_idx]['title'],
    'SimilarityScore': ...
})
Chaque ligne repr√©sente la meilleure correspondance entre un candidat et une offre

6. Export vers CSV
python
Copier
Modifier
df_recommendations.to_csv("meilleure_recommandation_par_candidat.csv")
Le fichier meilleure_recommandation_par_candidat.csv contient le top 1 offre par candidat

Il peut √™tre ouvert dans Excel, Power BI, ou visualis√© sur ton site Flask

Pourquoi dans cet algorithme de recommandation TF-IDF on n‚Äôa pas besoin de model.pkl ou scaler.pkl ?
Parce que ce n‚Äôest pas un algorithme "entra√Æn√©" comme une Random Forest, un XGBoost, un r√©seau de neurones, etc.

C‚Äôest un algorithme bas√© sur :

üß† TF-IDF vectorisation : transforme du texte en vecteurs

üìè cosine_similarity : compare la similarit√© entre deux textes vectoris√©s

Et tout cela est calcul√© √† la vol√©e √† chaque appel, sans entra√Ænement pr√©alable ‚úÖ